trigger:
  - main

variables:
  azureContainerRegistry: 'bestrong'
  azureResourceGroup: 'rg-bestrong'
  imageRepository: 'bestrong-api'
  tag: '$(Build.BuildId)'
  # Separate connection types for different Azure resources
  dockerRegistryServiceConnection: 'bestrong-acr'  # Docker registry connection
  azureRmServiceConnection: 'azure-conn'           # Azure Resource Manager connection
  # Using auto-generated domain with nip.io since we don't have a real domain
  # This will create a domain like bestrong-api.[LOAD_BALANCER_IP].nip.io
  domainName: 'auto-generate'

stages:
# Stage 1: Build & Push Docker Image to ACR
- stage: Build
  jobs:
  - job: BuildAndPush
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self

    - task: Docker@2
      displayName: 'Login to ACR'
      inputs:
        command: login
        containerRegistry: '$(dockerRegistryServiceConnection)' 

    - task: Docker@2
      displayName: 'Build and Push Docker Image'
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        repository: '$(imageRepository)'
        command: buildAndPush
        dockerfile: '$(Build.SourcesDirectory)/Dockerfile'
        tags: |
          $(tag)
          latest

# Stage 2: Package & Push Helm Chart to ACR
- stage: Package
  displayName: 'Package Helm Chart'
  jobs:
  - job: PackageHelmChart
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self

    - task: HelmInstaller@1
      inputs:
        helmVersionToInstall: 'latest'
    
    # Using Helm v3's OCI support instead of deprecated az acr helm commands
    - task: AzureCLI@2
      displayName: 'Push Helm Chart to ACR as OCI artifact'
      inputs:
        azureSubscription: '$(azureRmServiceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Login to ACR using the Azure CLI
          az acr login --name $(azureContainerRegistry)
          
          # Package the Helm chart
          helm package $(Build.SourcesDirectory)/Helm \
            --version $(Build.BuildId) \
            --destination $(Build.ArtifactStagingDirectory)
          
          # Push Helm chart as OCI artifact to ACR
          export HELM_EXPERIMENTAL_OCI=1
          CHART_PATH=$(Build.ArtifactStagingDirectory)/bestrong-$(Build.BuildId).tgz
          
          # Push the chart using Helm's OCI support
          helm push $CHART_PATH oci://$(azureContainerRegistry).azurecr.io/helm

# Stage 3: Deploy to AKS
- stage: Deploy
  displayName: 'Deploy to AKS'
  dependsOn:
    - Build
    - Package
  jobs:
  - deployment: DeployToAKS
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: HelmInstaller@1
            inputs:
              helmVersionToInstall: 'latest'

          - task: AzureCLI@2
            displayName: 'Deploy from ACR to AKS with HTTPS'
            inputs:
              azureSubscription: '$(azureRmServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "‚öôÔ∏è Getting AKS credentials..."
                az aks get-credentials -n aks-bestrong -g $(azureResourceGroup)

                echo "üì¶ Installing ingress-nginx with LoadBalancer..."
                helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
                helm repo update
                helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
                  --namespace ingress-nginx \
                  --create-namespace \
                  --set controller.service.type=LoadBalancer

                echo "üîí Installing cert-manager..."
                helm repo add jetstack https://charts.jetstack.io
                helm repo update
                helm upgrade --install cert-manager jetstack/cert-manager \
                  --namespace cert-manager \
                  --create-namespace \
                  --set installCRDs=true

                echo "‚è≥ Waiting for cert-manager to be ready..."
                kubectl -n cert-manager wait --for=condition=available deployment/cert-manager --timeout=120s
                kubectl -n cert-manager wait --for=condition=available deployment/cert-manager-webhook --timeout=120s

                # Get the LoadBalancer IP address for ingress-nginx
                echo "‚è≥ Waiting for LoadBalancer IP..."
                for i in {1..30}; do
                  INGRESS_IP=$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                  if [[ -n "$INGRESS_IP" ]]; then
                    break
                  fi
                  echo "Waiting for LoadBalancer IP... (attempt $i/30)"
                  sleep 10
                done

                if [[ -z "$INGRESS_IP" ]]; then
                  echo "‚ùå Failed to get LoadBalancer IP after 5 minutes. Exiting."
                  exit 1
                fi
                
                echo "‚úÖ LoadBalancer IP: $INGRESS_IP"
                
                # Using auto-generated domain with nip.io
                ACTUAL_DOMAIN="auto-generate"
                if [[ "$ACTUAL_DOMAIN" == "auto-generate" ]]; then
                  ACTUAL_DOMAIN="bestrong-api.$INGRESS_IP.nip.io"
                  echo "üåê Using auto-generated domain: $ACTUAL_DOMAIN"
                else
                  echo "üåê Using configured domain: $ACTUAL_DOMAIN"
                fi

                # Create ClusterIssuer for self-signed certificates
                echo "üîè Creating self-signed certificate issuer..."
                cat <<EOF | kubectl apply -f -
                apiVersion: cert-manager.io/v1
                kind: ClusterIssuer
                metadata:
                  name: selfsigned-issuer
                spec:
                  selfSigned: {}
                EOF
                ISSUER_NAME="selfsigned-issuer"
                
                echo "‚è≥ Waiting for ClusterIssuer to be ready..."
                sleep 10

                echo "üîê Logging in to ACR..."
                az acr login --name $(azureContainerRegistry)

                echo "‚§µÔ∏è Pulling Helm chart from ACR..."
                export HELM_EXPERIMENTAL_OCI=1
                helm pull oci://$(azureContainerRegistry).azurecr.io/helm/bestrong:$(Build.BuildId) --destination $(Agent.TempDirectory)

                echo "üöÄ Deploying chart to AKS with TLS configuration..."
                helm upgrade --install bestrong-api \
                  $(Agent.TempDirectory)/bestrong-$(Build.BuildId).tgz \
                  --set image.repository=$(azureContainerRegistry).azurecr.io/$(imageRepository) \
                  --set image.tag=$(tag) \
                  --set replicaCount=2 \
                  --set image.pullPolicy=IfNotPresent \
                  --set environment.ASPNETCORE_ENVIRONMENT=Production \
                  --set ingress.enabled=true \
                  --set ingress.annotations."kubernetes\.io/ingress\.class"=nginx \
                  --set ingress.annotations."cert-manager\.io/cluster-issuer"=$ISSUER_NAME \
                  --set ingress.hosts[0].host=$ACTUAL_DOMAIN \
                  --set ingress.hosts[0].paths[0].path=/ \
                  --set ingress.hosts[0].paths[0].pathType=Prefix \
                  --set ingress.tls[0].secretName=bestrong-api-tls \
                  --set ingress.tls[0].hosts[0]=$ACTUAL_DOMAIN \
                  --namespace default
                
                echo "üîç Checking certificate status..."
                sleep 30
                kubectl get certificate -A
                
                echo "üåê BeStrong API should now be accessible at: https://$ACTUAL_DOMAIN"
                echo "NOTE: It may take a few minutes for the certificate to be issued and propagated."